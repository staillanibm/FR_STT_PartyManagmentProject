// Jenkins Pipeline for FR_STT_PartyManagementProject CI/CD
// Single build that deploys to multiple OCP regions (zone-france, zone-latam)

pipeline {
    agent any

    parameters {
        string(
            name: 'VERSION_MAJOR',
            defaultValue: '1',
            description: 'Major version (e.g., 1, 2, 3)'
        )
        string(
            name: 'VERSION_MINOR',
            defaultValue: '0',
            description: 'Minor version (e.g., 0, 1, 2)'
        )
        string(
            name: 'OCP_REGISTRY',
            defaultValue: 'image-registry.openshift-image-registry.svc:5000',
            description: 'OpenShift internal registry address'
        )
        string(
            name: 'IMAGE_STREAM_NAME',
            defaultValue: 'cdf-party-management',
            description: 'ImageStream name in OpenShift'
        )
        string(
            name: 'ACR_PULL_SECRET',
            defaultValue: 'acr-pull-secret',
            description: 'Name of the OCP secret for ACR base image pull'
        )
        string(
            name: 'GIT_TOKEN_CREDENTIAL_ID',
            defaultValue: 'git-credentials',
            description: 'Jenkins credential ID for GitHub PAT'
        )
    }

    environment {
        // Version management - semantic versioning
        VERSION_BASE = "${params.VERSION_MAJOR}.${params.VERSION_MINOR}"

        // Calculate next patch number by finding max patch from existing tags
        NEXT_PATCH = sh(script: """
            # Fetch latest tags from remote to ensure we have all versions
            git fetch --tags --force 2>/dev/null || true

            # Get all tags matching VERSION_BASE pattern (e.g., "1.0.X")
            MAX_PATCH=0
            for tag in \$(git tag -l '${VERSION_BASE}.*' 2>/dev/null); do
                # Extract patch number from tag (e.g., "1.0.5" -> "5")
                PATCH=\${tag##*.}
                # Keep highest patch number
                if [ \$PATCH -gt \$MAX_PATCH ]; then
                    MAX_PATCH=\$PATCH
                fi
            done
            # Next patch is current max + 1, or 1 if no tags exist
            echo \$((MAX_PATCH + 1))
        """, returnStdout: true).trim()

        FULL_VERSION = "${VERSION_BASE}.${NEXT_PATCH}"

        // Both regions/namespaces
        OCP_NAMESPACES = "zone-france zone-latam"

        BUILD_CONTEXT = "${WORKSPACE}/resources/build"
        DOCKERFILE_PATH = "${WORKSPACE}/resources/build/Dockerfile_test"
    }

    options {
        buildDiscarder(logRotator(numToKeepStr: '30'))
        timeout(time: 3, unit: 'HOURS')
        disableConcurrentBuilds()
        timestamps()
    }

    stages {
        stage('Environment Setup') {
            steps {
                script {
                    echo "=========================================="
                    echo "Pipeline Configuration"
                    echo "=========================================="
                    echo "Version: ${FULL_VERSION}"
                    echo "Build Number: ${BUILD_NUMBER}"
                    echo "OCP Registry: ${params.OCP_REGISTRY}"
                    echo "Namespaces: ${OCP_NAMESPACES}"
                    echo "ImageStream: ${params.IMAGE_STREAM_NAME}:${FULL_VERSION}"
                    echo "Dockerfile: ${DOCKERFILE_PATH}"
                    echo "=========================================="
                }
            }
        }

        stage('SCM Checkout') {
            steps {
                script {
                    echo "Checking out source code..."
                    checkout scm
                }
            }
        }

        stage('Version Tag') {
            steps {
                script {
                    echo "Creating repository version tag: ${FULL_VERSION}"
                    withCredentials([string(credentialsId: params.GIT_TOKEN_CREDENTIAL_ID, variable: 'GIT_TOKEN')]) {
                        sh '''
                            # Configure git with token for push
                            git config user.name "Jenkins CI"
                            git config user.email "jenkins@sttlab.eu"

                            # Check if tag already exists
                            if git rev-parse "${FULL_VERSION}" >/dev/null 2>&1; then
                                echo "Tag ${FULL_VERSION} already exists. Skipping tag creation."
                            else
                                # Create annotated tag
                                git tag -a "${FULL_VERSION}" -m "Release version ${FULL_VERSION} - Build #${BUILD_NUMBER}"

                                # Push tag to remote using PAT token
                                REMOTE_URL=$(git config --get remote.origin.url)
                                case "${REMOTE_URL}" in
                                    https://*)
                                        REMOTE_WITH_TOKEN=$(echo "${REMOTE_URL}" | sed "s|https://|https://oauth2:${GIT_TOKEN}@|")
                                        git push "${REMOTE_WITH_TOKEN}" "${FULL_VERSION}"
                                        ;;
                                    *)
                                        echo "ERROR: Only HTTPS git URLs are supported for PAT authentication"
                                        exit 1
                                        ;;
                                esac
                                echo "✓ Tag ${FULL_VERSION} pushed to remote"
                            fi
                        '''
                    }
                }
            }
        }

        stage('Pre-Build Validation') {
            steps {
                script {
                    echo "Validating build prerequisites..."
                    sh '''
                        export PATH="/tools:$PATH"

                        # Check if Dockerfile exists
                        if [ ! -f "${DOCKERFILE_PATH}" ]; then
                            echo "ERROR: Dockerfile not found at ${DOCKERFILE_PATH}"
                            exit 1
                        fi
                        echo "✓ Dockerfile found"

                        # Check kubectl availability
                        if ! /tools/kubectl version > /dev/null 2>&1; then
                            echo "ERROR: kubectl not accessible"
                            exit 1
                        fi
                        echo "✓ kubectl is accessible"

                        # Verify access to both namespaces
                        for ns in ${OCP_NAMESPACES}; do
                            if ! /tools/kubectl get buildconfigs -n $ns > /dev/null 2>&1; then
                                echo "ERROR: Cannot access OCP namespace $ns"
                                exit 1
                            fi
                            echo "✓ OCP namespace $ns accessible"
                        done
                    '''
                }
            }
        }

        stage('Build and Deploy to All Regions') {
            steps {
                script {
                    withCredentials([
                        string(credentialsId: 'wpm-token', variable: 'WPM_TOKEN'),
                        string(credentialsId: 'git-credentials', variable: 'GIT_TOKEN')
                    ]) {
                        sh """
                            export PATH="/tools:\$PATH"

                            # Build and push to each namespace
                            for NAMESPACE in ${OCP_NAMESPACES}; do
                                echo "=========================================="
                                echo "Building for namespace: \$NAMESPACE"
                                echo "=========================================="

                                # Substitute variables in BuildConfig template
                                sed -e "s|\\\${OCP_NAMESPACE}|\$NAMESPACE|g" \
                                    -e "s|\\\${FULL_VERSION}|${FULL_VERSION}|g" \
                                    -e "s|\\\${WPM_TOKEN}|${WPM_TOKEN}|g" \
                                    -e "s|\\\${GIT_TOKEN}|${GIT_TOKEN}|g" \
                                    resources/build/BuildConfig.yaml | /tools/kubectl apply -f -

                                # Trigger the build by creating a Build resource
                                BUILD_OUTPUT=\$(sed -e "s|\\\${OCP_NAMESPACE}|\$NAMESPACE|g" \
                                    -e "s|\\\${FULL_VERSION}|${FULL_VERSION}|g" \
                                    -e "s|\\\${WPM_TOKEN}|${WPM_TOKEN}|g" \
                                    -e "s|\\\${GIT_TOKEN}|${GIT_TOKEN}|g" \
                                    resources/build/Build.yaml | /tools/kubectl create -f -)

                                # Extract Build name from output
                                BUILD_NAME=\$(echo "\${BUILD_OUTPUT}" | grep -oP 'cdf-party-management-build-[a-z0-9]+' || echo "")

                                if [ -z "\${BUILD_NAME}" ]; then
                                    echo "ERROR: Could not determine Build resource name for \$NAMESPACE"
                                    exit 1
                                fi

                                echo "Waiting for Build \${BUILD_NAME} in \$NAMESPACE to complete..."

                                # Wait for build to complete (max 30 minutes)
                                TIMEOUT=1800
                                ELAPSED=0
                                while [ \$ELAPSED -lt \$TIMEOUT ]; do
                                    PHASE=\$(/tools/kubectl get build \${BUILD_NAME} -n \$NAMESPACE -o jsonpath='{.status.phase}' 2>/dev/null || echo "")

                                    if [ "\${PHASE}" = "Complete" ]; then
                                        echo "✓ Build \${BUILD_NAME} completed successfully in \$NAMESPACE"
                                        break
                                    elif [ "\${PHASE}" = "Failed" ] || [ "\${PHASE}" = "Error" ]; then
                                        echo "ERROR: Build failed in \$NAMESPACE with phase: \${PHASE}"
                                        /tools/kubectl logs -n \$NAMESPACE \${BUILD_NAME}-build 2>/dev/null || true
                                        exit 1
                                    elif [ "\${PHASE}" = "Cancelled" ]; then
                                        echo "ERROR: Build was cancelled in \$NAMESPACE"
                                        exit 1
                                    fi

                                    echo "Build phase: \${PHASE}... (\$ELAPSED seconds)"
                                    sleep 10
                                    ELAPSED=\$((ELAPSED + 10))
                                done

                                if [ \$ELAPSED -ge \$TIMEOUT ]; then
                                    echo "ERROR: Build timeout after 30 minutes in \$NAMESPACE"
                                    exit 1
                                fi
                            done

                            echo "✓ Docker image built and pushed to all ImageStreams"
                        """
                    }
                }
            }
        }

        stage('CI Summary') {
            steps {
                script {
                    echo "=========================================="
                    echo "CI Pipeline Completed Successfully"
                    echo "=========================================="
                    echo "Version: ${FULL_VERSION}"
                    echo "ImageStream: ${params.IMAGE_STREAM_NAME}:${FULL_VERSION}"
                    echo "Regions: zone-france, zone-latam"
                    echo "Build Duration: ${currentBuild.durationString}"
                    echo "=========================================="
                }
            }
        }
    }

    post {
        always {
            script {
                echo "✓ Pipeline cleanup complete"
            }
        }
        failure {
            script {
                echo "ERROR: CI Pipeline failed"
            }
        }
        success {
            script {
                echo "SUCCESS: CI Pipeline completed"
            }
        }
    }
}
