// Jenkins Pipeline for FR_STT_PartyManagementProject CI/CD
// Declarative Pipeline with parameterized versioning

pipeline {
    agent {
        label "${params.REGION}"
    }

    parameters {
        choice(
            name: 'REGION',
            choices: ['france', 'latam'],
            description: 'Region/Namespace (france → zone-france, latam → zone-latam)'
        )
        string(
            name: 'VERSION_MAJOR',
            defaultValue: '1',
            description: 'Major version (e.g., 1, 2, 3)'
        )
        string(
            name: 'VERSION_MINOR',
            defaultValue: '0',
            description: 'Minor version (e.g., 0, 1, 2)'
        )
        string(
            name: 'OCP_REGISTRY',
            defaultValue: 'image-registry.openshift-image-registry.svc:5000',
            description: 'OpenShift internal registry address (e.g., image-registry.openshift-image-registry.svc:5000)'
        )
        string(
            name: 'IMAGE_STREAM_NAME',
            defaultValue: 'cdf-party-management',
            description: 'ImageStream name in OpenShift (e.g., cdf-party-management)'
        )
        string(
            name: 'ACR_PULL_SECRET',
            defaultValue: 'acr-pull-secret',
            description: 'Name of the OCP secret for ACR base image pull'
        )
        string(
            name: 'GIT_TOKEN_CREDENTIAL_ID',
            defaultValue: 'git-credentials',
            description: 'Jenkins credential ID for GitHub PAT (for git tag push)'
        )
    }

    environment {
        // Map region to OCP namespace
        OCP_NAMESPACE = sh(script: """
            case "${params.REGION}" in
                france) echo "zone-france" ;;
                latam) echo "zone-latam" ;;
                *) echo "ERROR: Unknown region"; exit 1 ;;
            esac
        """, returnStdout: true).trim()

        // Set working directory for all stages
        WORKSPACE_DIR = "${WORKSPACE}"
        BUILD_CONTEXT = "${WORKSPACE}/resources/build"
        DOCKERFILE_PATH = "${WORKSPACE}/resources/build/Dockerfile_test"

        // Version management - semantic versioning
        // MAJOR.MINOR.PATCH where PATCH = last tag patch number + 1
        VERSION_BASE = "${params.VERSION_MAJOR}.${params.VERSION_MINOR}"

        // Get the last patch number from git tags matching MAJOR.MINOR pattern
        LAST_PATCH = sh(script: """
            git tag -l '${VERSION_BASE}.*' 2>/dev/null | \
            sed 's/${VERSION_BASE}.\\([0-9]*\\)/\\1/' | \
            sort -n | tail -1
        """, returnStdout: true).trim()

        // Calculate next patch (if no tags exist, start with 1)
        NEXT_PATCH = sh(script: """
            LAST=\${LAST_PATCH:-0}
            echo \$((LAST + 1))
        """, returnStdout: true).trim()

        FULL_VERSION = "${VERSION_BASE}.${NEXT_PATCH}"

        // OCP ImageStream references
        IMAGE_STREAM_TAG = "${params.IMAGE_STREAM_NAME}:${FULL_VERSION}"
        IMAGE_STREAM_LATEST = "${params.IMAGE_STREAM_NAME}:latest"
        OCP_IMAGE_REFERENCE = "${params.OCP_REGISTRY}/${OCP_NAMESPACE}/${IMAGE_STREAM_TAG}"

        // Docker build tags (temporary, pushed to OCP ImageStream)
        DOCKER_BUILD_TAG = "${params.IMAGE_STREAM_NAME}:${FULL_VERSION}"
        DOCKER_BUILD_LATEST = "${params.IMAGE_STREAM_NAME}:latest"
    }

    options {
        // Keep last 30 builds
        buildDiscarder(logRotator(numToKeepStr: '30'))
        // Timeout for the entire pipeline
        timeout(time: 2, unit: 'HOURS')
        // Disable concurrent builds
        disableConcurrentBuilds()
        // Add timestamps to logs
        timestamps()
    }

    stages {
        stage('Environment Setup') {
            steps {
                script {
                    echo "=========================================="
                    echo "Pipeline Configuration"
                    echo "=========================================="
                    echo "Base Version: ${params.VERSION_BASE}"
                    echo "Build Number: ${BUILD_NUMBER}"
                    echo "Full Version: ${FULL_VERSION}"
                    echo "OCP Registry: ${params.OCP_REGISTRY}"
                    echo "OCP Namespace: ${params.OCP_NAMESPACE}"
                    echo "ImageStream: ${IMAGE_STREAM_TAG}"
                    echo "OCP Image Reference: ${OCP_IMAGE_REFERENCE}"
                    echo "Build Context: ${BUILD_CONTEXT}"
                    echo "Dockerfile: ${DOCKERFILE_PATH}"
                    echo "ACR Pull Secret: ${params.ACR_PULL_SECRET}"
                    echo "=========================================="
                }
            }
        }

        stage('SCM Checkout') {
            steps {
                script {
                    echo "Checking out source code..."
                    checkout scm
                }
            }
        }

        stage('Version Tag') {
            steps {
                script {
                    echo "Creating repository version tag: ${FULL_VERSION}"
                    withCredentials([string(credentialsId: params.GIT_TOKEN_CREDENTIAL_ID, variable: 'GIT_TOKEN')]) {
                        sh '''
                            # Configure git with token for push
                            git config user.name "Jenkins CI"
                            git config user.email "jenkins@sttlab.eu"

                            # Check if tag already exists
                            if git rev-parse "${FULL_VERSION}" >/dev/null 2>&1; then
                                echo "Tag ${FULL_VERSION} already exists. Skipping tag creation."
                            else
                                # Create annotated tag
                                git tag -a "${FULL_VERSION}" -m "Release version ${FULL_VERSION} - Build #${BUILD_NUMBER}"

                                # Push tag to remote using PAT token
                                # Extract remote URL and rewrite with token
                                REMOTE_URL=$(git config --get remote.origin.url)
                                case "${REMOTE_URL}" in
                                    https://*)
                                        # HTTPS URL: https://github.com/user/repo.git
                                        REMOTE_WITH_TOKEN=$(echo "${REMOTE_URL}" | sed "s|https://|https://oauth2:${GIT_TOKEN}@|")
                                        git push "${REMOTE_WITH_TOKEN}" "${FULL_VERSION}"
                                        ;;
                                    *)
                                        # SSH URL or other - use token auth
                                        echo "ERROR: Only HTTPS git URLs are supported for PAT authentication"
                                        exit 1
                                        ;;
                                esac
                                echo "✓ Tag ${FULL_VERSION} pushed to remote"
                            fi
                        '''
                    }
                }
            }
        }

        stage('Pre-Build Validation') {
            steps {
                script {
                    echo "Validating build prerequisites..."
                    sh '''
                        # Check if Dockerfile exists
                        if [ ! -f "${DOCKERFILE_PATH}" ]; then
                            echo "ERROR: Dockerfile not found at ${DOCKERFILE_PATH}"
                            exit 1
                        fi
                        echo "✓ Dockerfile found"

                        # Check Docker daemon
                        if ! docker ps > /dev/null 2>&1; then
                            echo "ERROR: Docker daemon not accessible"
                            exit 1
                        fi
                        echo "✓ Docker daemon is accessible"
                    '''
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    echo "Building Docker image using OCP BuildConfig: ${IMAGE_STREAM_TAG}"
                    sh '''
                        # Use OpenShift BuildConfig to build the image
                        # This approach doesn't require Docker daemon on the agent
                        oc new-build --name="${IMAGE_STREAM_NAME}-build" \
                            --dockerfile="Dockerfile_test" \
                            --context-dir="resources/build" \
                            -n "${OCP_NAMESPACE}" \
                            --to="${IMAGE_STREAM_NAME}:${FULL_VERSION}" \
                            --strategy=docker \
                            --build-arg="VERSION=${FULL_VERSION}" \
                            --build-arg="WPM_TOKEN=${WPM_TOKEN}" \
                            --build-arg="GIT_TOKEN=${GIT_TOKEN}" \
                            . || echo "BuildConfig already exists"

                        # Start the build and wait for completion
                        oc start-build "${IMAGE_STREAM_NAME}-build" -n "${OCP_NAMESPACE}" --from-dir="." --wait

                        echo "✓ Docker image built successfully"
                    '''
                }
            }
        }

        stage('Image Validation') {
            steps {
                script {
                    echo "Validating built ImageStream image..."
                    sh '''
                        echo "ImageStream image inspection:"
                        oc describe imagestream ${IMAGE_STREAM_NAME} -n ${OCP_NAMESPACE}
                    '''
                }
            }
        }

        stage('Verify Image in ImageStream') {
            steps {
                script {
                    echo "Verifying image pushed to OCP ImageStream: ${IMAGE_STREAM_TAG}"
                    sh '''
                        # Verify ImageStream exists and has the new image
                        if ! oc get imagestream ${IMAGE_STREAM_NAME} -n ${OCP_NAMESPACE} >/dev/null 2>&1; then
                            echo "ERROR: ImageStream ${IMAGE_STREAM_NAME} not found in namespace ${OCP_NAMESPACE}"
                            exit 1
                        fi
                        echo "✓ ImageStream found"

                        # Tag the image as latest
                        oc tag "${IMAGE_STREAM_NAME}:${FULL_VERSION}" "${IMAGE_STREAM_NAME}:latest" -n ${OCP_NAMESPACE}

                        echo "✓ Image verified in OCP ImageStream"
                        echo "ImageStream reference: ${IMAGE_STREAM_TAG}"
                    '''
                }
            }
        }

        stage('CI Summary') {
            steps {
                script {
                    echo "=========================================="
                    echo "CI Pipeline Completed Successfully"
                    echo "=========================================="
                    echo "Version: ${FULL_VERSION}"
                    echo "OCP ImageStream: ${IMAGE_STREAM_TAG}"
                    echo "ImageStream Reference: ${OCP_IMAGE_REFERENCE}"
                    echo "Build Duration: ${currentBuild.durationString}"
                    echo "=========================================="
                    echo ""
                    echo "Image is now available in OCP ImageStream"
                    echo "Next steps: Deploy to OCP using CD pipeline"
                }
            }
        }
    }

    post {
        always {
            script {
                echo "Cleaning up temporary resources..."
                sh '''
                    # Clean up old BuildConfigs (OCP native builds don't need cleanup)
                    echo "✓ Pipeline cleanup complete"
                '''
            }
        }
        failure {
            script {
                echo "ERROR: CI Pipeline failed"
            }
        }
        success {
            script {
                echo "SUCCESS: CI Pipeline completed"
            }
        }
    }
}
