// Jenkins Pipeline for FR_STT_PartyManagementProject CI/CD
// Declarative Pipeline with parameterized versioning

pipeline {
    agent {
        label "${params.REGION}"
    }

    parameters {
        choice(
            name: 'REGION',
            choices: ['france', 'latam'],
            description: 'Region/Namespace (france → zone-france, latam → zone-latam)'
        )
        string(
            name: 'VERSION_MAJOR',
            defaultValue: '1',
            description: 'Major version (e.g., 1, 2, 3)'
        )
        string(
            name: 'VERSION_MINOR',
            defaultValue: '0',
            description: 'Minor version (e.g., 0, 1, 2)'
        )
        string(
            name: 'OCP_REGISTRY',
            defaultValue: 'image-registry.openshift-image-registry.svc:5000',
            description: 'OpenShift internal registry address (e.g., image-registry.openshift-image-registry.svc:5000)'
        )
        string(
            name: 'IMAGE_STREAM_NAME',
            defaultValue: 'cdf-party-management',
            description: 'ImageStream name in OpenShift (e.g., cdf-party-management)'
        )
        string(
            name: 'ACR_PULL_SECRET',
            defaultValue: 'acr-pull-secret',
            description: 'Name of the OCP secret for ACR base image pull'
        )
        string(
            name: 'GIT_TOKEN_CREDENTIAL_ID',
            defaultValue: 'git-credentials',
            description: 'Jenkins credential ID for GitHub PAT (for git tag push)'
        )
    }

    environment {
        // Map region to OCP namespace
        OCP_NAMESPACE = sh(script: """
            case "${params.REGION}" in
                france) echo "zone-france" ;;
                latam) echo "zone-latam" ;;
                *) echo "ERROR: Unknown region"; exit 1 ;;
            esac
        """, returnStdout: true).trim()

        // Set working directory for all stages
        WORKSPACE_DIR = "${WORKSPACE}"
        BUILD_CONTEXT = "${WORKSPACE}/resources/build"
        DOCKERFILE_PATH = "${WORKSPACE}/resources/build/Dockerfile_test"

        // Version management - semantic versioning
        // MAJOR.MINOR.PATCH where PATCH = last tag patch number + 1
        VERSION_BASE = "${params.VERSION_MAJOR}.${params.VERSION_MINOR}"

        // Calculate next patch number by finding max patch from existing tags
        NEXT_PATCH = sh(script: """
            # Get all tags matching VERSION_BASE pattern (e.g., "1.0.X")
            MAX_PATCH=0
            for tag in \$(git tag -l '${VERSION_BASE}.*' 2>/dev/null); do
                # Extract patch number from tag (e.g., "1.0.5" -> "5")
                PATCH=\${tag##*.}
                # Keep highest patch number
                if [ \$PATCH -gt \$MAX_PATCH ]; then
                    MAX_PATCH=\$PATCH
                fi
            done
            # Next patch is current max + 1, or 1 if no tags exist
            echo \$((MAX_PATCH + 1))
        """, returnStdout: true).trim()

        FULL_VERSION = "${VERSION_BASE}.${NEXT_PATCH}"

        // OCP ImageStream references
        IMAGE_STREAM_TAG = "${params.IMAGE_STREAM_NAME}:${FULL_VERSION}"
        IMAGE_STREAM_LATEST = "${params.IMAGE_STREAM_NAME}:latest"
        OCP_IMAGE_REFERENCE = "${params.OCP_REGISTRY}/${OCP_NAMESPACE}/${IMAGE_STREAM_TAG}"

        // Docker build tags (temporary, pushed to OCP ImageStream)
        DOCKER_BUILD_TAG = "${params.IMAGE_STREAM_NAME}:${FULL_VERSION}"
        DOCKER_BUILD_LATEST = "${params.IMAGE_STREAM_NAME}:latest"
    }

    options {
        // Keep last 30 builds
        buildDiscarder(logRotator(numToKeepStr: '30'))
        // Timeout for the entire pipeline
        timeout(time: 2, unit: 'HOURS')
        // Disable concurrent builds
        disableConcurrentBuilds()
        // Add timestamps to logs
        timestamps()
    }

    stages {
        stage('Environment Setup') {
            steps {
                script {
                    echo "=========================================="
                    echo "Pipeline Configuration"
                    echo "=========================================="
                    echo "Base Version: ${params.VERSION_BASE}"
                    echo "Build Number: ${BUILD_NUMBER}"
                    echo "Full Version: ${FULL_VERSION}"
                    echo "OCP Registry: ${params.OCP_REGISTRY}"
                    echo "OCP Namespace: ${params.OCP_NAMESPACE}"
                    echo "ImageStream: ${IMAGE_STREAM_TAG}"
                    echo "OCP Image Reference: ${OCP_IMAGE_REFERENCE}"
                    echo "Build Context: ${BUILD_CONTEXT}"
                    echo "Dockerfile: ${DOCKERFILE_PATH}"
                    echo "ACR Pull Secret: ${params.ACR_PULL_SECRET}"
                    echo "=========================================="
                }
            }
        }

        stage('SCM Checkout') {
            steps {
                script {
                    echo "Checking out source code..."
                    checkout scm
                }
            }
        }

        stage('Version Tag') {
            steps {
                script {
                    echo "Creating repository version tag: ${FULL_VERSION}"
                    withCredentials([string(credentialsId: params.GIT_TOKEN_CREDENTIAL_ID, variable: 'GIT_TOKEN')]) {
                        sh '''
                            # Configure git with token for push
                            git config user.name "Jenkins CI"
                            git config user.email "jenkins@sttlab.eu"

                            # Check if tag already exists
                            if git rev-parse "${FULL_VERSION}" >/dev/null 2>&1; then
                                echo "Tag ${FULL_VERSION} already exists. Skipping tag creation."
                            else
                                # Create annotated tag
                                git tag -a "${FULL_VERSION}" -m "Release version ${FULL_VERSION} - Build #${BUILD_NUMBER}"

                                # Push tag to remote using PAT token
                                # Extract remote URL and rewrite with token
                                REMOTE_URL=$(git config --get remote.origin.url)
                                case "${REMOTE_URL}" in
                                    https://*)
                                        # HTTPS URL: https://github.com/user/repo.git
                                        REMOTE_WITH_TOKEN=$(echo "${REMOTE_URL}" | sed "s|https://|https://oauth2:${GIT_TOKEN}@|")
                                        git push "${REMOTE_WITH_TOKEN}" "${FULL_VERSION}"
                                        ;;
                                    *)
                                        # SSH URL or other - use token auth
                                        echo "ERROR: Only HTTPS git URLs are supported for PAT authentication"
                                        exit 1
                                        ;;
                                esac
                                echo "✓ Tag ${FULL_VERSION} pushed to remote"
                            fi
                        '''
                    }
                }
            }
        }

        stage('Pre-Build Validation') {
            steps {
                script {
                    echo "Validating build prerequisites..."
                    sh '''
                        export PATH="/tools:$PATH"

                        # Check if Dockerfile exists
                        if [ ! -f "${DOCKERFILE_PATH}" ]; then
                            echo "ERROR: Dockerfile not found at ${DOCKERFILE_PATH}"
                            exit 1
                        fi
                        echo "✓ Dockerfile found"

                        # Check kubectl availability
                        if ! /tools/kubectl version > /dev/null 2>&1; then
                            echo "ERROR: kubectl not accessible"
                            exit 1
                        fi
                        echo "✓ kubectl is accessible"

                        # Verify kubectl can access the API by listing buildconfigs
                        if ! /tools/kubectl get buildconfigs -n ${OCP_NAMESPACE} > /dev/null 2>&1; then
                            echo "ERROR: Cannot access OCP namespace ${OCP_NAMESPACE}"
                            exit 1
                        fi
                        echo "✓ OCP namespace ${OCP_NAMESPACE} accessible"
                    '''
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    echo "Building image via OCP BuildConfig: ${IMAGE_STREAM_TAG}"
                    withCredentials([
                        string(credentialsId: 'wpm-token', variable: 'WPM_TOKEN'),
                        string(credentialsId: 'git-credentials', variable: 'GIT_TOKEN')
                    ]) {
                        sh """
                            export PATH="/tools:\$PATH"

                            # Substitute variables in BuildConfig template using sed
                            sed -e "s|\\\${OCP_NAMESPACE}|${OCP_NAMESPACE}|g" \
                                -e "s|\\\${FULL_VERSION}|${FULL_VERSION}|g" \
                                -e "s|\\\${WPM_TOKEN}|${WPM_TOKEN}|g" \
                                -e "s|\\\${GIT_TOKEN}|${GIT_TOKEN}|g" \
                                resources/build/BuildConfig.yaml | /tools/kubectl apply -f -

                            # Trigger the build by creating a Build resource
                            BUILD_OUTPUT=\$(sed -e "s|\\\${OCP_NAMESPACE}|${OCP_NAMESPACE}|g" \
                                -e "s|\\\${FULL_VERSION}|${FULL_VERSION}|g" \
                                -e "s|\\\${WPM_TOKEN}|${WPM_TOKEN}|g" \
                                -e "s|\\\${GIT_TOKEN}|${GIT_TOKEN}|g" \
                                resources/build/Build.yaml | /tools/kubectl create -f -)

                            # Extract Build name from output (e.g., "build.build.openshift.io/cdf-party-management-build-xyz created")
                            BUILD_NAME=\$(echo "\${BUILD_OUTPUT}" | grep -oP 'cdf-party-management-build-[a-z0-9]+' || echo "")

                            if [ -z "\${BUILD_NAME}" ]; then
                                echo "ERROR: Could not determine Build resource name"
                                exit 1
                            fi

                            echo "Waiting for Build \${BUILD_NAME} to complete..."

                            # Wait for build to complete (max 30 minutes)
                            TIMEOUT=1800
                            ELAPSED=0
                            while [ \$ELAPSED -lt \$TIMEOUT ]; do
                                PHASE=\$(/tools/kubectl get build \${BUILD_NAME} -n ${OCP_NAMESPACE} -o jsonpath='{.status.phase}' 2>/dev/null || echo "")

                                if [ "\${PHASE}" = "Complete" ]; then
                                    echo "✓ Build completed successfully"
                                    break
                                elif [ "\${PHASE}" = "Failed" ] || [ "\${PHASE}" = "Error" ]; then
                                    echo "ERROR: Build failed with phase: \${PHASE}"
                                    /tools/kubectl logs -n ${OCP_NAMESPACE} \${BUILD_NAME}-build 2>/dev/null || true
                                    exit 1
                                elif [ "\${PHASE}" = "Cancelled" ]; then
                                    echo "ERROR: Build was cancelled"
                                    exit 1
                                fi

                                echo "Build phase: \${PHASE}... (\$ELAPSED seconds)"
                                sleep 10
                                ELAPSED=\$((ELAPSED + 10))
                            done

                            if [ \$ELAPSED -ge \$TIMEOUT ]; then
                                echo "ERROR: Build timeout after 30 minutes"
                                exit 1
                            fi

                            echo "✓ Docker image built and pushed to ImageStream"
                        """
                    }
                }
            }
        }

        stage('CI Summary') {
            steps {
                script {
                    echo "=========================================="
                    echo "CI Pipeline Completed Successfully"
                    echo "=========================================="
                    echo "Version: ${FULL_VERSION}"
                    echo "OCP ImageStream: ${IMAGE_STREAM_TAG}"
                    echo "ImageStream Reference: ${OCP_IMAGE_REFERENCE}"
                    echo "Build Duration: ${currentBuild.durationString}"
                    echo "=========================================="
                    echo ""
                    echo "Image is now available in OCP ImageStream"
                    echo "Next steps: Deploy to OCP using CD pipeline"
                }
            }
        }
    }

    post {
        always {
            script {
                echo "Cleaning up temporary resources..."
                sh '''
                    # Clean up old BuildConfigs (OCP native builds don't need cleanup)
                    echo "✓ Pipeline cleanup complete"
                '''
            }
        }
        failure {
            script {
                echo "ERROR: CI Pipeline failed"
            }
        }
        success {
            script {
                echo "SUCCESS: CI Pipeline completed"
            }
        }
    }
}
